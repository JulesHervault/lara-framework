import weaver.JoinPoints;
import weaver.Weaver;
import lara.util.JpFilter;
import lara.Check;

/**
 * Selects join points according to their type and filter rules.
 *
 */
var Selector = function($baseJp, inclusive) {
	this._$currentJps = $baseJp === undefined ? undefined : [$baseJp];
	this._joinPoints = new JoinPoints();
	this._addBaseJp = inclusive === undefined ? false : inclusive;
};


/// STATIC FUNCTIONS

Selector._parseFilter = function(filter, name) {
	// If undefined, return empty object
	if(filter === undefined) {
		//println("Empty filter");
		return {};
	}
	
	// If filter is not an object, build object with default attribute of given jp name
	if(!isObject(filter)) {
		// Get default attribute
		var defaultAttr = Weaver.getDefaultAttribute(name);
		
		// If no default attribute, return empty filter
		if(defaultAttr === undefined) {
			println("Selector: cannot use default filter for join point '"+name+"', it does not have a default attribute");
			return {};
		}
		
		var defaultFilter = {};
		defaultFilter[defaultAttr] = filter;
		//println("Default filter:");
		//printlnObject(defaultFilter);
		return defaultFilter;
	}
	
	// Just return the filter
	//println("Original filter:");
	//printlnObject(filter);
	return filter;
}	


/// INSTANCE FUNCTIONS

Selector.prototype.search = function(name, filter) {
	return this._searchPrivate(name, filter, function($jp, joinPoints, name) {return joinPoints.descendants($jp, name);});
}

Selector.prototype.children = function(name, filter) {
	return this._searchPrivate(name, filter, function($jp, joinPoints, name) {return joinPoints.children($jp, name);});
}

Selector.prototype._searchPrivate = function(name, filter, selectFunction) {

	Check.isDefined(selectFunction, "selectFunction");

	filter = Selector._parseFilter(filter, name);
	/*
	if(filter === undefined) {
		filter = {};
	}
	*/
	
	var jpFilter = new JpFilter(filter);
	
	var $newJps = [];

	// If add base jp, this._$currentJps must have at most 1 element
	if(this._addBaseJp && (this._$currentJps !== undefined)) {

		if(this._$currentJps.length === 0) {
			throw "Selector._searchPrivate: 'inclusive' is true, but currentJps is empty, can this happen?";
		}
		
		if(this._$currentJps.length > 1) {
			throw "Selector._searchPrivate: 'inclusive' is true, but currentJps is larger than one ('" + this._$currentJps.length + "')";
		}
		
		this._addBaseJp = false;
		
		// Filter does not test if the join point is of the right type
		if(this._$currentJps[0].instanceOf(name)) {
			this._addJps($newJps, this._$currentJps, jpFilter);		
		}

	}
	
	var $currentJps = this._$currentJps === undefined ? [this._joinPoints.root()] : this._$currentJps;
	for(var $jp of $currentJps) {
		
		var $allJps = selectFunction($jp, this._joinPoints, name);
		//var $allJps = this._joinPoints.descendants($jp);
		//println("All jps: " + $allJps.length);
		//for(var $jp of $allJps) {
		//	println("jp " + $jp.joinPointType + ":" + $jp.location);
		//}
		
		this._addJps($newJps, $allJps, jpFilter);
/*		
		var $filteredJps = jpFilter.filter($allJps);
		//println("filteredJps: " + $filteredJps.length);
		for(var $finalJp of $filteredJps) {
			$newJps.push($finalJp);
		}
*/		
		
	}

	// Update
	this._$currentJps = $newJps;
	
	return this;
}

Selector.prototype._addJps = function($newJps, $jps, jpFilter) {
		
	var $filteredJps = jpFilter.filter($jps);

	for(var $finalJp of $filteredJps) {
		$newJps.push($finalJp);
	}
}

Selector.prototype.get = function() {
	if(this._$currentJps === undefined) {
		println("Selector.get(): no join points have been searched, have you called a search function? (e.g., search, children)");
		return [];
	}
	
	var returnJps = this._$currentJps;
	this._$currentJps = undefined;
	return returnJps;
}

/**
 * Same as .first()
 */
Selector.prototype.getFirst = function() {
	var $jps = this.get();
	if($jps.length === 0) {
		println("Selector.getFirst(): no join point found");
		return undefined;
	}

	return $jps[0];
}

/**
 * @return {$jp} the first selected join point
 */
Selector.prototype.first = function() {
	return this.getFirst();
}