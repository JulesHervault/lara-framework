import weaver.JoinPoints;
import lara.util.JpFilter;
import lara.Check;

/**
 * Selects join points according to their type and filter rules.
 *
 */
var Selector = function($baseJp, inclusive) {
	this._$currentJps = $baseJp === undefined ? undefined : [$baseJp];
	this._joinPoints = new JoinPoints();
	this._addBaseJp = inclusive === undefined ? false : inclusive;
};

Selector.prototype.search = function(name, filter) {
	return this._searchPrivate(name, filter, function($jp, joinPoints, name) {return joinPoints.descendants($jp, name);});
}

Selector.prototype.children = function(name, filter) {
	return this._searchPrivate(name, filter, function($jp, joinPoints, name) {return joinPoints.children($jp, name);});
}

Selector.prototype._searchPrivate = function(name, filter, selectFunction) {

	Check.isDefined(selectFunction, "selectFunction");

	if(filter === undefined) {
		filter = {};
	}
	
	var jpFilter = new JpFilter(filter);
	
	var $newJps = [];

	// If add base jp, this._$currentJps must have at most 1 element
	if(this._addBaseJp && (this._$currentJps !== undefined)) {

		if(this._$currentJps.length === 0) {
			throw "Selector._searchPrivate: 'inclusive' is true, but currentJps is empty, can this happen?";
		}
		
		if(this._$currentJps.length > 1) {
			throw "Selector._searchPrivate: 'inclusive' is true, but currentJps is larger than one ('" + this._$currentJps.length + "')";
		}
		
		this._addBaseJp = false;
		this._addJps($newJps, this._$currentJps, jpFilter);		
	}

	
	var $currentJps = this._$currentJps === undefined ? [this._joinPoints.root()] : this._$currentJps;
	for(var $jp of $currentJps) {
		
		var $allJps = selectFunction($jp, this._joinPoints, name);
		//var $allJps = this._joinPoints.descendants($jp);
		//println("All jps: " + $allJps.length);
		//for(var $jp of $allJps) {
		//	println("jp " + $jp.joinPointType + ":" + $jp.location);
		//}
		
		this._addJps($newJps, $allJps, jpFilter);
/*		
		var $filteredJps = jpFilter.filter($allJps);
		//println("filteredJps: " + $filteredJps.length);
		for(var $finalJp of $filteredJps) {
			$newJps.push($finalJp);
		}
*/		
		
	}

	// Update
	this._$currentJps = $newJps;
	
	return this;
}

Selector.prototype._addJps = function($newJps, $jps, jpFilter) {
	var $filteredJps = jpFilter.filter($jps);
	//println("filteredJps: " + $filteredJps.length);
	for(var $finalJp of $filteredJps) {
		$newJps.push($finalJp);
	}
}

Selector.prototype.get = function() {
	if(this._$currentJps === undefined) {
		println("Selector.get(): no join points have been searched, have you called a search function? (e.g., search, children)");
		return [];
	}
	
	var returnJps = this._$currentJps;
	this._$currentJps = undefined;
	return returnJps;
}

/**
 * Same as .first()
 */
Selector.prototype.getFirst = function() {
	var $jps = this.get();
	if($jps.length === 0) {
		println("Selector.getFirst(): no join point found");
		return undefined;
	}

	return $jps[0];
}

/**
 * @return {$jp} the first selected join point
 */
Selector.prototype.first = function() {
	return this.getFirst();
}