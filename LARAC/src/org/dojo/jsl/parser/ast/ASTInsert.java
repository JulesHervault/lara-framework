/* Generated By:JJTree: Do not edit this line. ASTInsert.java Version 4.3 */
/*
 * JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,
 * NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true
 */
package org.dojo.jsl.parser.ast;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Map;

import javax.xml.bind.DatatypeConverter;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import larac.objects.Enums;
import larac.objects.Enums.Types;
import larac.utils.OrganizeUtils;
import larac.utils.xml.entity.ActionArgument;

public class ASTInsert extends SimpleNode {
    private String when;
    private String language;
    private ASTCodeDef codeDef;
    private String codeFileName;
    private boolean pureCode;
    private final ArrayList<String> codeParams = new ArrayList<>();
    private Map<String, SimpleNode> codeMapping = new LinkedHashMap<>();

    public ASTInsert(int id) {
        super(id);
    }

    public ASTInsert(LARAEcmaScript p, int id) {
        super(p, id);
    }

    public void setWhen(String when) {
        this.when = when;
        value = when;
    }

    public String getWhen() {
        return when;
    }

    @Override
    public String toString() {
        return LARAEcmaScriptTreeConstants.jjtNodeName[id] + " [" + when + "," + language + "]";
    }

    /**
     * @param language
     *            the language to set
     */
    public void setLanguage(String language) {
        this.language = language;
    }

    /**
     * @return the language
     */
    public String getLanguage() {
        return language;
    }

    /**
     * @param codeMapping
     *            the paramMapping to set
     */
    public void setCodeMapping(LinkedHashMap<String, SimpleNode> codeMapping) {
        this.codeMapping = codeMapping;
    }

    /**
     * @return the paramMapping
     */
    public Map<String, SimpleNode> getCodeMapping() {
        return codeMapping;
    }

    @Override
    public Object organize(Object obj) {

        final ASTAction act = (ASTAction) parent;
        act.setMethod("insert");
        act.setArguments(OrganizeUtils.createInsertParameters(getLara().languageSpec()));
        final Map<String, ActionArgument> arguments = act.getArguments();
        if (jjtGetChild(0) instanceof ASTFunctionCallParameters) {
            final ASTFunctionCallParameters params = (ASTFunctionCallParameters) jjtGetChild(0);
            if (params.areNamed) {
                for (final Node param : params.getChildren()) {
                    final ASTNamedArgument na = (ASTNamedArgument) param;
                    if (!arguments.containsKey(na.value)) {
                        throw newException("The argument '" + na.value + "' does not exist for action 'insert'");
                    }
                    final ActionArgument actArg = arguments.get(na.value);
                    // if (na.value.equals("code")) {
                    // verifyCodeDef(na.jjtGetChild(0), arguments);
                    // } else {
                    na.organize(obj);
                    actArg.setValue((SimpleNode) na.jjtGetChild(0));
                    // }
                }
            } else {
                if (params.getChildren().length != arguments.size()) {
                    throw newException("Illegal number of arguments for action 'insert'");
                }
                params.getChild(0).organize(this);
                arguments.get("position").setValue(params.getChild(0));
                params.getChild(1).organize(this);
                arguments.get("code").setValue(params.getChild(1));
                // verifyCodeDef(params.jjtGetChild(1), arguments);
            }
        } else {
            arguments.get("position").setValue(when);
            // if (children[0] instanceof ASTLiteral) {
            // ((SimpleNode) children[0]).organize(this);
            // arguments.get("code").setValue((SimpleNode) children[0]);
            // } else {
            SimpleNode codeExpr = getChild(0);
            codeExpr.organize(this);
            arguments.get("code").setValue(codeExpr);
            // verifyCodeDef(children[0], arguments);
            // }
        }
        return null;
    }

    /*
    private void verifyCodeDef(Node node, Map<String, ActionArgument> arguments) {
        String codeName = "";
        if (node instanceof ASTLiteral) { // This will never happen!
            ((SimpleNode) node).organize(this);
    
            arguments.get("code").setValue((SimpleNode) node);
            return;
        }
        if (node instanceof ASTIdentifier) {
            codeName = ((ASTIdentifier) node).value.toString();
            // codeDef = getLara().aspectIR().getCodedef(codeName);
            // if (codeDef == null) {
            Variable lookupNoError = lookupNoError(codeName);
            if (lookupNoError == null) {
                // getLara().warnln("Did not find a codedef but found : " + lookupNoError.getName());
                // } else {
                throw newException("No codedef nor variable was found for name '" + codeName + "'.");
            }
            // }else
            // throw newException("No Codedef nor variable exists with name '" + codeName + "'.");
            // }
        } else if (node instanceof ASTCompositeReference) {
    
            codeName = ((ASTIdentifier) node.jjtGetChild(0)).value.toString();
            // codeDef = getLara().aspectIR().getCodedef(codeName);
            final ASTFunctionCallParameters params = (ASTFunctionCallParameters) node.jjtGetChild(1);
            // if (codeDef == null) {
            // Variable lookupNoError = lookupNoError(codeName);
            // if (lookupNoError != null) {
            // getLara().warnln("Did not find a codedef but found : " + lookupNoError.getName());
            // } else {
            // throw newException("No codedef nor variable was found for name '" + codeName + "'.");
            // }
            // params.organize(this);
            // } else {
    
            for (final String arg : codeDef.getArguments()) {
                codeMapping.put(arg, null);
            }
    
            organizeArguments(params);
            // }
    
        } else {
            throw newException("Argument 'code' for insert is invalid.");
        }
    
        arguments.get("code").setValue(this);
    }
    
    private void organizeArguments(ASTFunctionCallParameters astFunctionCallParameters) {
        if (astFunctionCallParameters.areNamed) {
            for (final Node node : astFunctionCallParameters.getSimpleNodeChildren()) {
                final ASTNamedArgument named = (ASTNamedArgument) node;
                if (!codeDef.getArguments().contains(named.value)) {
                    throw newException("In Action 'insert': '" + named.value + "' does not exist.");
                }
                ((SimpleNode) named.getChildren()[0]).organize(this);
                getCodeMapping().put(named.value.toString(), (SimpleNode) named.getChildren()[0]);
            }
        } else {
            for (final SimpleNode node : astFunctionCallParameters.getSimpleNodeChildren()) {
                final String arg = getParamWithNoValue();
                if (arg == null) {
                    throw newException("In Action 'insert': Illegal number of arguments");
                }
                node.organize(this);
                codeMapping.put(arg, node);
            }
        }
    
        for (final SimpleNode sn : codeMapping.values()) {
            if (sn == null) {
                String unsigned = "";
                for (final String nulls : codeMapping.keySet()) {
                    if (codeMapping.get(nulls) == null) {
                        unsigned += nulls + ",";
                    }
                }
                unsigned = unsigned.substring(0, unsigned.length() - 1);
                throw newException("In Action 'insert': not all codedef arguments are set: " + unsigned);
            }
        }
    }
    
    private String getParamWithNoValue() {
        for (final String param : codeMapping.keySet()) {
            if (codeMapping.get(param) == null) {
                return param;
            }
        }
        return null;
    }
    */
    /**
     * @param codeDef
     *            the codeDef to set
     */
    public void setCodeDef(ASTCodeDef codeDef) {
        this.codeDef = codeDef;
    }

    /**
     * @return the codeDef
     */
    public ASTCodeDef getCodeDef() {
        return codeDef;
    }

    /**
     * @param codeFileName
     *            the codeFileName to set
     */
    public void setCodeFileName(String codeFileName) {
        this.codeFileName = codeFileName;
    }

    /**
     * @return the codeFileName
     */
    public String getCodeFileName() {
        return codeFileName;
    }

    /**
     * @param pureCode
     *            the pureCode to set
     */
    public void setPureCode(boolean pureCode) {
        this.pureCode = pureCode;
    }

    /**
     * @return the pureCode
     */
    public boolean isPureCode() {
        return pureCode;
    }

    @Override
    public void toXMLTemplate(Document doc, Element parent) {

        final Element literalEl = doc.createElement("literal");
        literalEl.setAttribute("type", Types.Object.toString());
        literalEl.setAttribute("desc", Types.Code.toString());
        parent.appendChild(literalEl);
        final Element propEl = doc.createElement("key");
        propEl.setAttribute("name", "code");
        literalEl.appendChild(propEl);
        if (codeDef != null) {
            addCodeDef(doc, propEl);
        } else {
            getChild(0).toXML(doc, propEl);
        }

        for (final String prop : codeMapping.keySet()) {
            final SimpleNode replace = codeMapping.get(prop);
            final Element propertyKeyEl = doc.createElement("key");
            literalEl.appendChild(propertyKeyEl);
            propertyKeyEl.setAttribute("name", Enums.SYMBOL_BEGIN + prop + Enums.SYMBOL_END);
            replace.toXML(doc, propertyKeyEl);
        }
        codeTemplateArgumentsToXML(doc, literalEl, codeParams);
    }

    public void addCodeDef(Document doc, final Element propEl) {
        final Element stringEl = doc.createElement("literal");
        stringEl.setAttribute("type", Types.Base64.toString());
        propEl.appendChild(stringEl);
        try {
            final String codeBase64 = DatatypeConverter.printBase64Binary(codeDef.getCode().getBytes("UTF-8"));
            stringEl.setAttribute("value", codeBase64);
        } catch (final UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

}
/*
 * JavaCC - OriginalChecksum=dc1f61881b611a8788d045963882552a (do not edit this
 * line)
 */
