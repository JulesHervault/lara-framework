/* Generated By:JJTree: Do not edit this line. ASTApply.java Version 4.3 */
/*
 * JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,
 * NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true
 */
package org.dojo.jsl.parser.ast;

import java.util.HashMap;
import java.util.Map;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import larac.LaraC;
import larac.objects.Variable;

public class ASTApply extends SimpleNode {
    private String name;
    private ASTAroundApply before, after;
    private ASTCondition condition;
    public int codeCount = 0;
    private int toPosition;
    private ASTSelect activeSelect;
    private boolean dynamic = false;
    private Boolean concurrent = false;
    private String trigger = "before";

    // private int bodyPosition = -1;

    public ASTApply(int id) {
        super(id);
    }

    public ASTApply(LARAEcmaScript p, int id) {
        super(p, id);
    }

    public void setName(String image) {
        value = name = label = image;
    }

    public String getName() {
        return name;
    }

    @Override
    public Object organize(Object obj) {
        // final ASTAspectDef aspectDef = ((ASTAspectDef) obj);
        final ASTAspectDef aspectDef = getAspectDefForDeclStmt("Apply");

        if (name == null) {
            value = name = aspectDef.getName() + "_apply_" + aspectDef.getApplyCount();
            aspectDef.setLastApplyWithNoLabel(this);
        }

        setBefore(aspectDef.getLastbeforeWithNoLabel());

        if (!(children[0] instanceof ASTTo)) {
            setToWithUnlabelledSelect(aspectDef);
        }

        if (isDynamic()) {
            processDynamicConditions(aspectDef);
        }

        ((ASTTo) getChildren()[0]).organize(this); // js.organize inside

        aspectDef.putApply(this);
        return null;
    }

    /**
     * //Process conditions, which are location between the To (0) and the JavaScript Nodes (children.lenght-1), hence:
     * ]0,lenght-1[
     * 
     * @param aspectDef
     */
    private static void processDynamicConditions(ASTAspectDef aspectDef) {
        // What has to be done here? do we need to validate something inside the apply?
        //
        // throw new NotImplementedException("The dynamic conditions are not yet implemented");
    }

    /**
     * Create an ASTTo with the last select that has no label
     * 
     * @param aspectDef
     * @return
     */
    private void setToWithUnlabelledSelect(ASTAspectDef aspectDef) {
        final ASTSelect sel = aspectDef.getLastSelectWithNoLabel();
        // aspectDef.setLastSelectWithNoLabel(null);
        if (sel == null) {
            throw newException("Unknown select for apply :\"" + name + "\"");
        }
        final ASTTo to = new ASTTo(LARAEcmaScriptTreeConstants.JJTTO);
        final ASTIdentifier id = new ASTIdentifier(LARAEcmaScriptTreeConstants.JJTIDENTIFIER);
        id.jjtSetValue(sel.getName());
        to.associateChild(id, 0);
        appendChildAsFirst(to);
        to.parent = this;
    }

    public ASTSelect getSelect(String value) {
        // final ASTAspectDef aspect = (ASTAspectDef) parent;
        final ASTAspectDef aspect = getAspectDefForDeclStmt("Apply");
        return aspect.getSelect(value);
    }

    @Override
    public void toXML(Document doc, Element parent) {

        // final ASTAspectDef aspect = (ASTAspectDef) this.parent;
        final ASTAspectDef aspect = getAspectDefForDeclStmt("Apply");
        final ASTTo to = (ASTTo) children[0]; // First node should always be an ASTTo

        if (dynamic) {
            System.out.println(outsideVariables);
        }

        toPosition = 0;
        int count = 0;
        ASTCondition condition = null;
        if (aspect.containsCondition(getName())) {
            condition = aspect.getCondition(getName());
        }
        int length = to.children.length;
        while (toPosition < length) {
            setActiveSelect(to.selects.get(toPosition));
            final String applyName = getName() + "_" + count++;
            final Element applyEl = doc.createElement("statement");
            applyEl.setAttribute("coord", lookDownCoords());
            parent.appendChild(applyEl);
            applyEl.setAttribute("name", "apply");
            applyEl.setAttribute("label", applyName);
            applyEl.setAttribute("dynamic", Boolean.toString(dynamic));
            applyEl.setAttribute("concurrent", Boolean.toString(concurrent));
            applyEl.setAttribute("execute", trigger);

            to.toXML(doc, applyEl, toPosition);
            setCondition(doc, condition, applyEl, applyName);

            if (before != null && before.children[0].jjtGetNumChildren() != 0) {
                before.toXML(doc, applyEl);
            } else {
                final Element applyBeforeEl = doc.createElement("code");
                applyBeforeEl.setAttribute("desc", "before");
                applyEl.appendChild(applyBeforeEl);
            }

            final Element applyCodeEl = doc.createElement("code");
            applyCodeEl.setAttribute("desc", "do");
            applyEl.appendChild(applyCodeEl);
            ((SimpleNode) getChildren()[1]).toXML(doc, applyCodeEl);
            if (after != null && after.children[0].jjtGetNumChildren() != 0) {
                after.toXML(doc, applyEl);
            } else {
                final Element applyAfterEl = doc.createElement("code");
                applyAfterEl.setAttribute("desc", "after");
                applyEl.appendChild(applyAfterEl);
            }

            toPosition++;
            setActiveSelect(null);
        }
    }

    private static void setCondition(Document doc, ASTCondition condition, Element applyEl, String applyName) {
        if (condition != null) {
            condition.toXML(doc, applyEl);
        } else {
            applyEl.appendChild(doc.createElement("expression"));
        }
    }

    /**
     * @param before
     *            the before to set
     */
    public void setBefore(ASTAroundApply before) {
        if (this.before != null) {
            final LaraC lara = getLara();
            lara.warnln("Apply \"" + name + "\" contains more than one before statement. First will be used");
            return;
        }
        this.before = before;
    }

    /**
     * @return the before
     */
    public ASTAroundApply getBefore() {
        return before;
    }

    /**
     * @param after
     *            the after to set
     */
    public void setAfter(ASTAroundApply after) {
        if (this.after != null) {
            getLara().warnln("Apply \"" + name + "\" contains more than one after statement. First will be used");
            return;
        }
        this.after = after;
    }

    /**
     * @return the after
     */
    public ASTAroundApply getAfter() {
        return after;
    }

    /**
     * @param condition
     *            the condition to set
     */
    public void setCondition(ASTCondition condition) {
        if (this.condition != null) {
            getLara().warnln("Apply \"" + name + "\" contains more than one condition. First will be used");
            return;
        }
        this.condition = condition;
    }

    /**
     * @return the condition
     */
    public ASTCondition getCondition() {
        return condition;
    }

    public void organizeCondition() {
        ((ASTTo) getChildren()[0]).organizeCondition(this);

    }

    public String getSelectLastJPVar() {
        final ASTSelect sel = ((ASTTo) children[0]).selects.get(toPosition);
        return sel.getLastJPVariable().getName();
    }

    @Override
    public Variable lookup(String var) {
        if (before != null) {
            if (before.getJs().getHMVars().containsKey(var)) {
                return before.getJs().getHMVars().get(var);
            }
        }
        Variable getVar = super.lookupNoError(var);
        if (getVar != null && !outsideVariables.containsKey(getVar.getName())) {
            outsideVariables.put(getVar.getName(), getVar);
        }

        return getVar;
    }

    private Map<String, Variable> outsideVariables = new HashMap<>();

    @Override
    public Variable lookupNoError(String var) {
        if (before != null) {
            if (before.getJs().getHMVars().containsKey(var)) {
                return before.getJs().getHMVars().get(var);
            }
        }
        Variable getVar = super.lookupNoError(var);
        if (getVar != null && !outsideVariables.containsKey(getVar.getName())) {
            outsideVariables.put(getVar.getName(), getVar);
        }
        return getVar;
    }

    public void organizeAfter() {
        if (after != null) {
            after.organizeForApply(this);
        }
    }

    public void setActiveSelect(ASTSelect astSelect) {
        activeSelect = astSelect;
    }

    public ASTSelect getActiveSelect() {
        return activeSelect;
    }

    public boolean isDynamic() {
        return dynamic;
    }

    public void setDynamic(boolean isDynamic) {
        dynamic = isDynamic;
    }

    @Override
    public String toString() {

        String toString = LARAEcmaScriptTreeConstants.jjtNodeName[id];
        if (dynamic) {
            return toString + " [static]";
        }

        toString += " [dynamic ";
        toString += concurrent ? "par" : "seq";
        toString += " " + trigger;
        return toString + "]";
    }

    public ASTJavaScript getBody() {
        // if (bodyPosition == -1) {
        // searchBody();
        // }
        // return (ASTJavaScript) children[bodyPosition];
        return (ASTJavaScript) children[children.length - 1];
    }

    /**
     * @return the parallel
     */
    public boolean isParallel() {
        return concurrent;
    }

    /**
     * @param parallel
     *            the parallel to set
     */
    public void setConcurrent(boolean parallel) {
        concurrent = parallel;
    }

    public void setTrigger(String string) {
        trigger = string;

    }

    // private void searchBody() {
    // for (int i = 0; i < children.length; i++) {
    // if (children[i] instanceof ASTJavaScript) {
    // bodyPosition = i;
    // return;
    // }
    // }
    // }
}
/*
 * JavaCC - OriginalChecksum=eab81715be50293fb9681ab9499db9c9 (do not edit this
 * line)
 */
