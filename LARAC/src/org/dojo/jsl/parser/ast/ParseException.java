/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 5.0 */
/* JavaCCOptions:KEEP_LINE_COL=null */
package org.dojo.jsl.parser.ast;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.Function;

import tdrc.utils.StringUtils;

/**
 * This exception is thrown when parse errors are encountered. You can explicitly create objects of this exception type
 * by calling the method generateParseException in the generated parser.
 *
 * You can modify this class to customize your error reporting mechanisms so long as you retain the public fields.
 */
@SuppressWarnings("all")
public class ParseException extends Exception {

    /**
     * The version identifier for this Serializable class. Increment only if the <i>serialized</i> form of the class
     * changes.
     */
    private static final long serialVersionUID = 1L;

    /**
     * This constructor is used by the method "generateParseException" in the generated parser. Calling this constructor
     * generates a new object of this type with the fields "currentToken", "expectedTokenSequences", and "tokenImage"
     * set.
     */
    public ParseException(Token currentTokenVal, int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
	super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
	currentToken = currentTokenVal;
	expectedTokenSequences = expectedTokenSequencesVal;
	tokenImage = tokenImageVal;
	nextToken = currentTokenVal.next;
	errorMessage = getMessage().substring(getMessage().indexOf(":") + 1);
	expectedTokenSet = buildSequenceList(expectedTokenSequences, tokenImage);
    }

    private static List<String> buildSequenceList(int[][] expectedTokenSequences, String[] tokenImage) {
	// this.expectedTokenSet = new HashSet<>();
	List<String> tokens = new ArrayList<>();
	for (int i = 0; i < expectedTokenSequences.length; i++) {
	    for (int j = 0; j < expectedTokenSequences[i].length; j++) {
		String token = (tokenImage[expectedTokenSequences[i][j]]);
		if (!tokens.contains(token)) {
		    tokens.add(token);
		}
	    }
	}
	String semiColon = tokenImage[LARAEcmaScriptConstants.SEMICOLON];
	if (tokens.contains(semiColon)) {
	    Collections.rotate(tokens.subList(0, tokens.indexOf(semiColon) + 1), 1);
	}
	return tokens;
    }

    /**
     * The following constructors are for use by you for whatever purpose you can think of. Constructing the exception
     * in this manner makes the exception behave in the normal way - i.e., as documented in the class "Throwable". The
     * fields "errorToken", "expectedTokenSequences", and "tokenImage" do not contain relevant information. The JavaCC
     * generated code does not use these constructors.
     */

    public ParseException() {
	super();
    }

    /** Constructor with message. */
    public ParseException(String message) {
	super(message);
    }

    /**
     * This is the last token that has been consumed successfully. If this object has been created due to a parse error,
     * the token followng this token will (therefore) be the first error token.
     */
    public Token currentToken;
    private Token nextToken;
    private String errorMessage;

    /**
     * Each entry in this array is an array of integers. Each array of integers represents a sequence of tokens (by
     * their ordinal values) that is expected at this point of the parse.
     */
    public int[][] expectedTokenSequences;
    public List<String> expectedTokenSet;

    /**
     * This is a reference to the "tokenImage" array of the generated parser within which the parse error occurred. This
     * array is defined in the generated ...Constants interface.
     */
    public String[] tokenImage;

    /**
     * It uses "currentToken" and "expectedTokenSequences" to generate a parse error message and returns it. If this
     * object has been created due to a parse error, and you do not catch it (it gets thrown from the parser) the
     * correct error message gets displayed.
     */
    private static String initialise(Token currentToken, int[][] expectedTokenSequences, String[] tokenImage) {
	String eol = System.getProperty("line.separator", "\n");
	StringBuffer expected = new StringBuffer();
	int maxSize = 0;
	List<String> expectedList = buildSequenceList(expectedTokenSequences, tokenImage);
	for (int i = 0; i < expectedTokenSequences.length; i++) {
	    if (maxSize < expectedTokenSequences[i].length) {
		maxSize = expectedTokenSequences[i].length;
	    }
	}
	// String semiColon = tokenImage[LARAEcmaScriptConstants.SEMICOLON];
	// if (expectedList.contains(semiColon)) {
	// Collections.rotate(expectedList.subList(0, expectedList.indexOf(semiColon) + 1), 1);
	// }

	Function<String, String> quote2tick = s -> s.replace("\"", "'");
	String expectedListStr = "\n\t" + StringUtils.join(expectedList, quote2tick, "\n\t");
	expected.append(expectedListStr);
	// String retval = "Parse Exception: encountered ";// token ";
	Token nextToken = currentToken.next;
	String retval = "at line " + nextToken.beginLine + ", column " + nextToken.beginColumn + ":";
	String errorMessage = "encountered ";
	Token tok = nextToken;
	for (int i = 0; i < maxSize; i++) {

	    if (tok.kind == 0) {
		errorMessage += tokenImage[0];
		break;
	    }
	    errorMessage += " \"";
	    errorMessage += add_escapes(tok.image);
	    errorMessage += "\"";
	    tok = tok.next;
	}

	errorMessage += ", ";
	if (expectedTokenSequences.length == 1) {
	    errorMessage += "was expecting: "; // + eol + " ";
	} else {
	    errorMessage += "was expecting: "; // + eol + " ";
	}
	errorMessage += expected.toString();

	return retval + errorMessage;
    }

    /**
     * The end of line string for this machine.
     */
    protected String eol = System.getProperty("line.separator", "\n");

    /**
     * Used to convert raw characters to their escaped version when these raw version cannot be used as part of an ASCII
     * string literal.
     */
    static String add_escapes(String str) {
	StringBuffer retval = new StringBuffer();
	char ch;
	for (int i = 0; i < str.length(); i++) {
	    switch (str.charAt(i)) {
	    case 0:
		continue;
	    case '\b':
		retval.append("\\b");
		continue;
	    case '\t':
		retval.append("\\t");
		continue;
	    case '\n':
		retval.append("\\n");
		continue;
	    case '\f':
		retval.append("\\f");
		continue;
	    case '\r':
		retval.append("\\r");
		continue;
	    case '\"':
		retval.append("\\\"");
		continue;
	    case '\'':
		retval.append("\\\'");
		continue;
	    case '\\':
		retval.append("\\\\");
		continue;
	    default:
		if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
		    String s = "0000" + Integer.toString(ch, 16);
		    retval.append("\\u" + s.substring(s.length() - 4, s.length()));
		} else {
		    retval.append(ch);
		}
		continue;
	    }
	}
	return retval.toString();
    }

    public String getErrorMessage() {
	return errorMessage;
    }

    public Token getNextToken() {
	return nextToken;
    }

}
/*
 * JavaCC - OriginalChecksum=aa856bee2d7bc1f2756879db49b0ff38 (do not edit this
 * line)
 */