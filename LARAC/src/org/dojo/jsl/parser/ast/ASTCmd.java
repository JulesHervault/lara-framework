/* Generated By:JJTree: Do not edit this line. ASTCmd.java Version 4.3 */
/*
 * JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,
 * NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true
 */
package org.dojo.jsl.parser.ast;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import larac.objects.Enums.AssignOperator;
import larac.objects.Enums.Types;
import larac.utils.OrganizeUtils;

public @SuppressWarnings("all") class ASTCmd extends SimpleNode {
	private static final int numOfJSCMDMethod = 4;
	private boolean newVersion = false;

	public ASTCmd(int id) {
		super(id);
	}

	public ASTCmd(LARAEcmaScript p, int id) {
		super(p, id);
	}

	@Override
	public Object organize(Object obj) {
		int pos = 0;
		if (!(children[pos] instanceof ASTFunctionCallParameters)) {
			pos++;
		}

		final ASTFunctionCallParameters args = (ASTFunctionCallParameters) children[pos];
		args.organize(obj);
		if (args.jjtGetNumChildren() == 0) {
			throw newException("No argument was given in 'cmd'. At least a command is required to execute.");
		}

		if (newVersion) {

			return null;
		}

		final int remainingArgs = ASTCmd.numOfJSCMDMethod - args.jjtGetNumChildren();

		if (remainingArgs < 0) {
			getLara().warnln("A total of " + args.jjtGetNumChildren()
					+ " arguments was used in the command execution, the required number of arguments are: "
					+ (ASTCmd.numOfJSCMDMethod - 1) + ". This may lead to issues in the command execution.");
		} else if (remainingArgs == 0 && (pos < children.length)) {
			getLara().warnln(ASTCmd.numOfJSCMDMethod
					+ " arguments and a pipe in the 'cmd' method. However, the last argument overrides the used pipe.");
		}

		return null;
	}

	@Override
	public void toXML(Document doc, Element parent) {
		final Element statementEl = doc.createElement("statement");
		statementEl.setAttribute("coord", getCoords());
		statementEl.setAttribute("name", "expr");
		parent.appendChild(statementEl);

		final Element exprEl = doc.createElement("expression");
		statementEl.appendChild(exprEl);
		int pos = 0;
		Element current = exprEl;
		if (!(children[pos] instanceof ASTFunctionCallParameters)) {
			// Then it is a left hand side expression
			final Element opEl = doc.createElement("op");
			opEl.setAttribute("name", AssignOperator.ASSIGN.name());
			exprEl.appendChild(opEl);
			((SimpleNode) children[pos]).toXML(doc, opEl);
			pos++;
			current = opEl;
		}

		final Element callEl = doc.createElement("call");
		current.appendChild(callEl);
		final Element methodEl = doc.createElement("method");
		callEl.appendChild(methodEl);
		final Element runIDEl = doc.createElement("id");
		runIDEl.setAttribute("name", "cmd");
		methodEl.appendChild(runIDEl);
		final ASTFunctionCallParameters args = (ASTFunctionCallParameters) children[pos++];

		if (isNewVersion()) {
			toXMLOfNewVersion(doc, pos, callEl, args);
		} else { // old version was used

			toXMLOldVersion(doc, pos, callEl, args);
		}
	}

	/**
	 * Generate the arguments of the use of old cmd method
	 * 
	 * @param doc
	 * @param pos
	 * @param callEl
	 * @param args
	 */
	private void toXMLOldVersion(Document doc, int pos, Element callEl, ASTFunctionCallParameters args) {
		args.toXML(doc, callEl);
		final int remainingArgs = ASTCmd.numOfJSCMDMethod - args.jjtGetNumChildren();
		if (remainingArgs <= 0) {
			return;
		}

		final Element pipeEl = doc.createElement("argument");

		if (args.areNamed) {
			pipeEl.setAttribute("name", "pipe");
		} else {
			// Fill the missing arguments with 'undefined'
			for (int i = 0; i < remainingArgs - 1; i++) {
				final Element argEl = doc.createElement("argument");
				callEl.appendChild(argEl);
				OrganizeUtils.createLiteralUndefined(doc, argEl);
			}

		}

		// Only appended here so it can be the last argument, including the
		// undefined arguments before
		callEl.appendChild(pipeEl);

		if (pos < children.length) {
			final SimpleNode pipeExpr = (SimpleNode) children[pos];
			pipeExpr.toXML(doc, pipeEl);
		} else {
			OrganizeUtils.createLiteralUndefined(doc, pipeEl);
		}
	}

	/**
	 * Generate the arguments of the use of new cmd method
	 */
	private void toXMLOfNewVersion(Document doc, int pos, Element callEl, ASTFunctionCallParameters args) {
		// Then is the new run version

		setArgumentsAsList(args, doc, callEl);

		Element argEl = doc.createElement("argument");
		argEl.setAttribute("name", "verbose");
		callEl.appendChild(argEl);
		final Element litEl = doc.createElement("literal");
		litEl.setAttribute("type", Types.Int.toString());
		litEl.setAttribute("value", String.valueOf(2));
		argEl.appendChild(litEl);
		argEl = doc.createElement("argument");
		argEl.setAttribute("name", "pipe");
		callEl.appendChild(argEl);
		if (pos < children.length) {
			final SimpleNode pipeExpr = (SimpleNode) children[pos];
			pipeExpr.toXML(doc, argEl);
		} else {
			OrganizeUtils.createLiteralUndefined(doc, argEl);
		}
	}

	private void setArgumentsAsList(ASTFunctionCallParameters args, Document doc, Element parentEl) {

		Element argEl = doc.createElement("argument");
		argEl.setAttribute("name", "command");
		parentEl.appendChild(argEl);
		SimpleNode arg = (SimpleNode) args.jjtGetChild(0);
		arg.toXML(doc, argEl);

		argEl = doc.createElement("argument");
		parentEl.appendChild(argEl);
		argEl.setAttribute("name", "args");
		final Element litEl = doc.createElement("literal");
		argEl.appendChild(litEl);

		litEl.setAttribute("type", "array");
		for (int i = 1; i < args.getChildren().length; i++) {
			arg = (SimpleNode) args.jjtGetChild(i);
			final Element keyEl = doc.createElement("key");
			keyEl.setAttribute("name", String.valueOf(i - 1));
			litEl.appendChild(keyEl);
			arg.toXML(doc, keyEl);
		}

	}

	/**
	 * @return the newVersion
	 */
	public boolean isNewVersion() {
		return newVersion;
	}

	/**
	 * @param newVersion
	 *            the newVersion to set
	 */
	public void setNewVersion(boolean newVersion) {
		this.newVersion = newVersion;
	}

}
/*
 * JavaCC - OriginalChecksum=52fd5a98cc9622d4b30cd075148aab99 (do not edit this
 * line)
 */
